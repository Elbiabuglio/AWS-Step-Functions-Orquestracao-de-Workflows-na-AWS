# ðŸŽ¯ Boas PrÃ¡ticas - AWS Step Functions

## ðŸ—ï¸ Design de Workflows

### 1. PrincÃ­pio da Responsabilidade Ãšnica
Cada estado deve ter uma responsabilidade bem definida e especÃ­fica.

```json
// âŒ Evite: Estado que faz muitas coisas
{
  "ProcessEverything": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:DoEverything"
  }
}

// âœ… Prefira: Estados especÃ­ficos
{
  "ValidateInput": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ValidateInput",
    "Next": "ProcessData"
  },
  "ProcessData": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessData",
    "Next": "SaveResults"
  }
}
```

### 2. NomeaÃ§Ã£o Consistente
Use nomes descritivos e siga uma convenÃ§Ã£o consistente.

```json
// âœ… Bons nomes
{
  "ValidateUserInput": { ... },
  "ProcessPayment": { ... },
  "SendConfirmationEmail": { ... },
  "UpdateOrderStatus": { ... }
}

// âŒ Nomes ruins
{
  "Step1": { ... },
  "DoStuff": { ... },
  "Task": { ... }
}
```

### 3. Estrutura HierÃ¡rquica
Organize workflows complexos usando estados aninhados.

```json
{
  "ProcessOrder": {
    "Type": "Parallel",
    "Branches": [
      {
        "StartAt": "ValidatePayment",
        "States": {
          "ValidatePayment": { ... },
          "ProcessPayment": { ... },
          "ConfirmPayment": { ... }
        }
      },
      {
        "StartAt": "CheckInventory",
        "States": {
          "CheckInventory": { ... },
          "ReserveItems": { ... },
          "UpdateInventory": { ... }
        }
      }
    ]
  }
}
```

## ðŸ”„ Gerenciamento de Estado e Dados

### 1. Minimize o Payload
Passe apenas os dados necessÃ¡rios entre estados.

```json
// âŒ Evite: Passar dados desnecessÃ¡rios
{
  "ProcessUser": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessUser",
    "InputPath": "$"  // Passa tudo
  }
}

// âœ… Prefira: Passar apenas o necessÃ¡rio
{
  "ProcessUser": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessUser",
    "InputPath": "$.user"  // Passa apenas dados do usuÃ¡rio
  }
}
```

### 2. Use ResultPath Estrategicamente
Preserve dados importantes e adicione resultados sem sobrescrever.

```json
{
  "EnrichData": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:EnrichData",
    "ResultPath": "$.enrichment",  // Adiciona sem sobrescrever
    "Next": "ProcessEnrichedData"
  }
}
```

### 3. TransformaÃ§Ã£o de Dados
Use estados Pass para transformaÃ§Ãµes simples.

```json
{
  "FormatOutput": {
    "Type": "Pass",
    "Parameters": {
      "statusCode": 200,
      "body": {
        "success": true,
        "data.$": "$.processedData",
        "timestamp.$": "$$.State.EnteredTime"
      }
    },
    "End": true
  }
}
```

## âš ï¸ Tratamento de Erros e ResilÃªncia

### 1. ConfiguraÃ§Ã£o de Retry Apropriada
Configure retry com backoff exponencial para falhas transitÃ³rias.

```json
{
  "CallExternalService": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:CallAPI",
    "Retry": [
      {
        "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException"],
        "IntervalSeconds": 2,
        "MaxAttempts": 6,
        "BackoffRate": 2.0
      },
      {
        "ErrorEquals": ["States.TaskFailed"],
        "IntervalSeconds": 1,
        "MaxAttempts": 3,
        "BackoffRate": 1.5
      }
    ]
  }
}
```

### 2. Tratamento de Erros EspecÃ­ficos
Trate diferentes tipos de erro de forma apropriada.

```json
{
  "ProcessPayment": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessPayment",
    "Catch": [
      {
        "ErrorEquals": ["PaymentDeclined"],
        "Next": "HandleDeclinedPayment",
        "ResultPath": "$.error"
      },
      {
        "ErrorEquals": ["InsufficientFunds"],
        "Next": "NotifyInsufficientFunds",
        "ResultPath": "$.error"
      },
      {
        "ErrorEquals": ["States.ALL"],
        "Next": "HandleGenericError",
        "ResultPath": "$.error"
      }
    ]
  }
}
```

### 3. Implementar Circuit Breaker
Para serviÃ§os externos instÃ¡veis.

```json
{
  "CheckServiceHealth": {
    "Type": "Choice",
    "Choices": [
      {
        "Variable": "$.serviceHealth.status",
        "StringEquals": "DOWN",
        "Next": "ServiceUnavailable"
      },
      {
        "Variable": "$.serviceHealth.errorRate",
        "NumericGreaterThan": 0.5,
        "Next": "ServiceDegraded"
      }
    ],
    "Default": "CallService"
  }
}
```

## â±ï¸ Timeouts e Performance

### 1. Configure Timeouts Apropriados
Defina timeouts baseados no SLA esperado.

```json
{
  "QuickTask": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:QuickTask",
    "TimeoutSeconds": 10  // Para tarefas rÃ¡pidas
  },
  "LongRunningTask": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:LongTask",
    "TimeoutSeconds": 900,  // 15 minutos para tarefas longas
    "HeartbeatSeconds": 60   // Heartbeat para monitorar progresso
  }
}
```

### 2. Use ParalelizaÃ§Ã£o Quando Apropriado
Execute tarefas independentes em paralelo.

```json
{
  "ProcessInParallel": {
    "Type": "Parallel",
    "Branches": [
      {
        "StartAt": "ProcessImages",
        "States": { ... }
      },
      {
        "StartAt": "ProcessText",
        "States": { ... }
      },
      {
        "StartAt": "ProcessMetadata",
        "States": { ... }
      }
    ],
    "Next": "CombineResults"
  }
}
```

### 3. Otimize Estados Map
Use MaxConcurrency para controlar paralelismo.

```json
{
  "ProcessItems": {
    "Type": "Map",
    "ItemsPath": "$.items",
    "MaxConcurrency": 10,  // Limita para evitar throttling
    "Iterator": {
      "StartAt": "ProcessItem",
      "States": { ... }
    }
  }
}
```

## ðŸ” SeguranÃ§a

### 1. PrincÃ­pio do Menor PrivilÃ©gio
IAM roles com permissÃµes mÃ­nimas necessÃ¡rias.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "lambda:InvokeFunction"
      ],
      "Resource": "arn:aws:lambda:us-east-1:123456789012:function:SpecificFunction"
    },
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem"
      ],
      "Resource": "arn:aws:dynamodb:us-east-1:123456789012:table/SpecificTable"
    }
  ]
}
```

### 2. Criptografia de Dados
Use KMS para dados sensÃ­veis.

```json
{
  "StoreSecureData": {
    "Type": "Task",
    "Resource": "arn:aws:states:::dynamodb:putItem",
    "Parameters": {
      "TableName": "SecureData",
      "Item": {
        "Id": {"S.$": "$.id"},
        "EncryptedData": {
          "S.$": "States.StringToJson(States.Base64Encode($.sensitiveData))"
        }
      }
    }
  }
}
```

### 3. Evite Dados SensÃ­veis em Logs
Use ResultPath: null para nÃ£o logar resultados.

```json
{
  "ProcessSensitiveData": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessSensitive",
    "ResultPath": null,  // NÃ£o adiciona resultado ao estado
    "Next": "NextStep"
  }
}
```

## ðŸ’° OtimizaÃ§Ã£o de Custos

### 1. Escolha o Tipo de Workflow Correto

#### Standard Workflows
- **Quando usar**: Workflows de longa duraÃ§Ã£o, auditoria necessÃ¡ria
- **CaracterÃ­sticas**: ExecuÃ§Ã£o atÃ© 1 ano, histÃ³rico completo

#### Express Workflows
- **Quando usar**: Alto volume, baixa latÃªncia, execuÃ§Ãµes curtas
- **CaracterÃ­sticas**: ExecuÃ§Ã£o atÃ© 5 minutos, menor custo por execuÃ§Ã£o

### 2. Minimize TransiÃ§Ãµes de Estado
Combine operaÃ§Ãµes quando possÃ­vel.

```json
// âŒ Muitas transiÃ§Ãµes desnecessÃ¡rias
{
  "Step1": { "Type": "Pass", "Next": "Step2" },
  "Step2": { "Type": "Pass", "Next": "Step3" },
  "Step3": { "Type": "Pass", "Next": "Step4" }
}

// âœ… Combine em uma Ãºnica operaÃ§Ã£o
{
  "ProcessData": {
    "Type": "Pass",
    "Parameters": {
      "result": "All processing done in one step"
    },
    "Next": "NextMeaningfulStep"
  }
}
```

### 3. Use SDK Integrations
Evite Lambda functions para operaÃ§Ãµes simples.

```json
// âŒ Lambda desnecessÃ¡rio
{
  "SaveToDynamoDB": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:SaveToDDB"
  }
}

// âœ… SDK Integration direto
{
  "SaveToDynamoDB": {
    "Type": "Task",
    "Resource": "arn:aws:states:::dynamodb:putItem",
    "Parameters": {
      "TableName": "MyTable",
      "Item": {
        "id": {"S.$": "$.id"}
      }
    }
  }
}
```

## ðŸ“Š Monitoramento e Observabilidade

### 1. Logging Estruturado
Implemente logging consistente.

```json
{
  "LogWorkflowStart": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:Logger",
    "Parameters": {
      "level": "INFO",
      "event": "WORKFLOW_STARTED",
      "workflowName": "OrderProcessing",
      "executionId.$": "$$.Execution.Id",
      "input.$": "$",
      "timestamp.$": "$$.State.EnteredTime"
    },
    "ResultPath": null,
    "Next": "StartProcessing"
  }
}
```

### 2. MÃ©tricas Customizadas
Envie mÃ©tricas para CloudWatch.

```json
{
  "RecordMetric": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:RecordMetric",
    "Parameters": {
      "MetricName": "OrdersProcessed",
      "Value": 1,
      "Unit": "Count",
      "Dimensions": {
        "WorkflowName": "OrderProcessing"
      }
    },
    "ResultPath": null,
    "Next": "ContinueWorkflow"
  }
}
```

### 3. Alertas Proativos
Configure alertas para falhas.

```json
{
  "HandleCriticalError": {
    "Type": "Task",
    "Resource": "arn:aws:states:::sns:publish",
    "Parameters": {
      "TopicArn": "arn:aws:sns:us-east-1:123456789012:critical-alerts",
      "Subject": "Critical Workflow Failure",
      "Message": {
        "workflowName": "OrderProcessing",
        "executionId.$": "$$.Execution.Id",
        "error.$": "$.error",
        "timestamp.$": "$$.State.EnteredTime"
      }
    }
  }
}
```

## ðŸ§ª Testes e Desenvolvimento

### 1. Use Step Functions Local
Para desenvolvimento e testes locais.

```bash
# Instalar Step Functions Local
docker pull amazon/aws-stepfunctions-local

# Executar localmente
docker run -p 8083:8083 amazon/aws-stepfunctions-local
```

### 2. Testes UnitÃ¡rios para Estados
Teste cada estado individualmente.

```javascript
// Exemplo em Node.js
const AWS = require('aws-sdk');
const stepfunctions = new AWS.StepFunctions({
  endpoint: 'http://localhost:8083'
});

describe('Workflow Tests', () => {
  test('should validate input correctly', async () => {
    const params = {
      stateMachineArn: 'arn:aws:states:local:123456789:stateMachine:TestWorkflow',
      input: JSON.stringify({ order: { id: '123' } })
    };
    
    const result = await stepfunctions.startExecution(params).promise();