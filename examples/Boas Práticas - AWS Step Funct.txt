# üéØ Boas Pr√°ticas - AWS Step Functions

## üèóÔ∏è Design de Workflows

### 1. Princ√≠pio da Responsabilidade √önica
Cada estado deve ter uma responsabilidade bem definida e espec√≠fica.

```json
// ‚ùå Evite: Estado que faz muitas coisas
{
  "ProcessEverything": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:DoEverything"
  }
}

// ‚úÖ Prefira: Estados espec√≠ficos
{
  "ValidateInput": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ValidateInput",
    "Next": "ProcessData"
  },
  "ProcessData": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessData",
    "Next": "SaveResults"
  }
}
```

### 2. Nomea√ß√£o Consistente
Use nomes descritivos e siga uma conven√ß√£o consistente.

```json
// ‚úÖ Bons nomes
{
  "ValidateUserInput": { ... },
  "ProcessPayment": { ... },
  "SendConfirmationEmail": { ... },
  "UpdateOrderStatus": { ... }
}

// ‚ùå Nomes ruins
{
  "Step1": { ... },
  "DoStuff": { ... },
  "Task": { ... }
}
```

### 3. Estrutura Hier√°rquica
Organize workflows complexos usando estados aninhados.

```json
{
  "ProcessOrder": {
    "Type": "Parallel",
    "Branches": [
      {
        "StartAt": "ValidatePayment",
        "States": {
          "ValidatePayment": { ... },
          "ProcessPayment": { ... },
          "ConfirmPayment": { ... }
        }
      },
      {
        "StartAt": "CheckInventory",
        "States": {
          "CheckInventory": { ... },
          "ReserveItems": { ... },
          "UpdateInventory": { ... }
        }
      }
    ]
  }
}
```

## üîÑ Gerenciamento de Estado e Dados

### 1. Minimize o Payload
Passe apenas os dados necess√°rios entre estados.

```json
// ‚ùå Evite: Passar dados desnecess√°rios
{
  "ProcessUser": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessUser",
    "InputPath": "$"  // Passa tudo
  }
}

// ‚úÖ Prefira: Passar apenas o necess√°rio
{
  "ProcessUser": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessUser",
    "InputPath": "$.user"  // Passa apenas dados do usu√°rio
  }
}
```

### 2. Use ResultPath Estrategicamente
Preserve dados importantes e adicione resultados sem sobrescrever.

```json
{
  "EnrichData": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:EnrichData",
    "ResultPath": "$.enrichment",  // Adiciona sem sobrescrever
    "Next": "ProcessEnrichedData"
  }
}
```

### 3. Transforma√ß√£o de Dados
Use estados Pass para transforma√ß√µes simples.

```json
{
  "FormatOutput": {
    "Type": "Pass",
    "Parameters": {
      "statusCode": 200,
      "body": {
        "success": true,
        "data.$": "$.processedData",
        "timestamp.$": "$$.State.EnteredTime"
      }
    },
    "End": true
  }
}
```

## ‚ö†Ô∏è Tratamento de Erros e Resil√™ncia

### 1. Configura√ß√£o de Retry Apropriada
Configure retry com backoff exponencial para falhas transit√≥rias.

```json
{
  "CallExternalService": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:CallAPI",
    "Retry": [
      {
        "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException"],
        "IntervalSeconds": 2,
        "MaxAttempts": 6,
        "BackoffRate": 2.0
      },
      {
        "ErrorEquals": ["States.TaskFailed"],
        "IntervalSeconds": 1,
        "MaxAttempts": 3,
        "BackoffRate": 1.5
      }
    ]
  }
}
```

### 2. Tratamento de Erros Espec√≠ficos
Trate diferentes tipos de erro de forma apropriada.

```json
{
  "ProcessPayment": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessPayment",
    "Catch": [
      {
        "ErrorEquals": ["PaymentDeclined"],
        "Next": "HandleDeclinedPayment",
        "ResultPath": "$.error"
      },
      {
        "ErrorEquals": ["InsufficientFunds"],
        "Next": "NotifyInsufficientFunds",
        "ResultPath": "$.error"
      },
      {
        "ErrorEquals": ["States.ALL"],
        "Next": "HandleGenericError",
        "ResultPath": "$.error"
      }
    ]
  }
}
```

### 3. Implementar Circuit Breaker
Para servi√ßos externos inst√°veis.

```json
{
  "CheckServiceHealth": {
    "Type": "Choice",
    "Choices": [
      {
        "Variable": "$.serviceHealth.status",
        "StringEquals": "DOWN",
        "Next": "ServiceUnavailable"
      },
      {
        "Variable": "$.serviceHealth.errorRate",
        "NumericGreaterThan": 0.5,
        "Next": "ServiceDegraded"
      }
    ],
    "Default": "CallService"
  }
}
```

## ‚è±Ô∏è Timeouts e Performance

### 1. Configure Timeouts Apropriados
Defina timeouts baseados no SLA esperado.

```json
{
  "QuickTask": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:QuickTask",
    "TimeoutSeconds": 10  // Para tarefas r√°pidas
  },
  "LongRunningTask": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:LongTask",
    "TimeoutSeconds": 900,  // 15 minutos para tarefas longas
    "HeartbeatSeconds": 60   // Heartbeat para monitorar progresso
  }
}
```

### 2. Use Paraleliza√ß√£o Quando Apropriado
Execute tarefas independentes em paralelo.

```json
{
  "ProcessInParallel": {
    "Type": "Parallel",
    "Branches": [
      {
        "StartAt": "ProcessImages",
        "States": { ... }
      },
      {
        "StartAt": "ProcessText",
        "States": { ... }
      },
      {
        "StartAt": "ProcessMetadata",
        "States": { ... }
      }
    ],
    "Next": "CombineResults"
  }
}
```

### 3. Otimize Estados Map
Use MaxConcurrency para controlar paralelismo.

```json
{
  "ProcessItems": {
    "Type": "Map",
    "ItemsPath": "$.items",
    "MaxConcurrency": 10,  // Limita para evitar throttling
    "Iterator": {
      "StartAt": "ProcessItem",
      "States": { ... }
    }
  }
}
```

## üîê Seguran√ßa

### 1. Princ√≠pio do Menor Privil√©gio
IAM roles com permiss√µes m√≠nimas necess√°rias.

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "lambda:InvokeFunction"
      ],
      "Resource": "arn:aws:lambda:us-east-1:123456789012:function:SpecificFunction"
    },
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem"
      ],
      "Resource": "arn:aws:dynamodb:us-east-1:123456789012:table/SpecificTable"
    }
  ]
}
```

### 2. Criptografia de Dados
Use KMS para dados sens√≠veis.

```json
{
  "StoreSecureData": {
    "Type": "Task",
    "Resource": "arn:aws:states:::dynamodb:putItem",
    "Parameters": {
      "TableName": "SecureData",
      "Item": {
        "Id": {"S.$": "$.id"},
        "EncryptedData": {
          "S.$": "States.StringToJson(States.Base64Encode($.sensitiveData))"
        }
      }
    }
  }
}
```

### 3. Evite Dados Sens√≠veis em Logs
Use ResultPath: null para n√£o logar resultados.

```json
{
  "ProcessSensitiveData": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:ProcessSensitive",
    "ResultPath": null,  // N√£o adiciona resultado ao estado
    "Next": "NextStep"
  }
}
```

## üí∞ Otimiza√ß√£o de Custos

### 1. Escolha o Tipo de Workflow Correto

#### Standard Workflows
- **Quando usar**: Workflows de longa dura√ß√£o, auditoria necess√°ria
- **Caracter√≠sticas**: Execu√ß√£o at√© 1 ano, hist√≥rico completo

#### Express Workflows
- **Quando usar**: Alto volume, baixa lat√™ncia, execu√ß√µes curtas
- **Caracter√≠sticas**: Execu√ß√£o at√© 5 minutos, menor custo por execu√ß√£o

### 2. Minimize Transi√ß√µes de Estado
Combine opera√ß√µes quando poss√≠vel.

```json
// ‚ùå Muitas transi√ß√µes desnecess√°rias
{
  "Step1": { "Type": "Pass", "Next": "Step2" },
  "Step2": { "Type": "Pass", "Next": "Step3" },
  "Step3": { "Type": "Pass", "Next": "Step4" }
}

// ‚úÖ Combine em uma √∫nica opera√ß√£o
{
  "ProcessData": {
    "Type": "Pass",
    "Parameters": {
      "result": "All processing done in one step"
    },
    "Next": "NextMeaningfulStep"
  }
}
```

### 3. Use SDK Integrations
Evite Lambda functions para opera√ß√µes simples.

```json
// ‚ùå Lambda desnecess√°rio
{
  "SaveToDynamoDB": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:SaveToDDB"
  }
}

// ‚úÖ SDK Integration direto
{
  "SaveToDynamoDB": {
    "Type": "Task",
    "Resource": "arn:aws:states:::dynamodb:putItem",
    "Parameters": {
      "TableName": "MyTable",
      "Item": {
        "id": {"S.$": "$.id"}
      }
    }
  }
}
```

## üìä Monitoramento e Observabilidade

### 1. Logging Estruturado
Implemente logging consistente.

```json
{
  "LogWorkflowStart": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:Logger",
    "Parameters": {
      "level": "INFO",
      "event": "WORKFLOW_STARTED",
      "workflowName": "OrderProcessing",
      "executionId.$": "$$.Execution.Id",
      "input.$": "$",
      "timestamp.$": "$$.State.EnteredTime"
    },
    "ResultPath": null,
    "Next": "StartProcessing"
  }
}
```

### 2. M√©tricas Customizadas
Envie m√©tricas para CloudWatch.

```json
{
  "RecordMetric": {
    "Type": "Task",
    "Resource": "arn:aws:lambda:us-east-1:123456789012:function:RecordMetric",
    "Parameters": {
      "MetricName": "OrdersProcessed",
      "Value": 1,
      "Unit": "Count",
      "Dimensions": {
        "WorkflowName": "OrderProcessing"
      }
    },
    "ResultPath": null,
    "Next": "ContinueWorkflow"
  }
}
```

### 3. Alertas Proativos
Configure alertas para falhas.

```json
{
  "HandleCriticalError": {
    "Type": "Task",
    "Resource": "arn:aws:states:::sns:publish",
    "Parameters": {
      "TopicArn": "arn:aws:sns:us-east-1:123456789012:critical-alerts",
      "Subject": "Critical Workflow Failure",
      "Message": {
        "workflowName": "OrderProcessing",
        "executionId.$": "$$.Execution.Id",
        "error.$": "$.error",
        "timestamp.$": "$$.State.EnteredTime"
      }
    }
  }
}
```

## üß™ Testes e Desenvolvimento

### 1. Use Step Functions Local
Para desenvolvimento e testes locais.

```bash
# Instalar Step Functions Local
docker pull amazon/aws-stepfunctions-local

# Executar localmente
docker run -p 8083:8083 amazon/aws-stepfunctions-local
```

### 2. Testes Unit√°rios para Estados
Teste cada estado individualmente.

```javascript
// Exemplo em Node.js
const AWS = require('aws-sdk');
const stepfunctions = new AWS.StepFunctions({
  endpoint: 'http://localhost:8083'
});

describe('Workflow Tests', () => {
  test('should validate input correctly', async () => {
    const params = {
      stateMachineArn: 'arn:aws:states:local:123456789:stateMachine:TestWorkflow',
      input: JSON.stringify({ order: { id: '123' } })
    };
    
    const result = await stepfunctions.startExecution(params).promise();